Metadata-Version: 2.1
Name: quick-sqlite
Version: 1.0.3
Summary: A high-level SQLite3 wrapper that makes using SQLite databases much, much easier.
Home-page: https://github.com/MilaBot/Quick-SQLite
Author: JackTEK
Author-email: jacktek@jacktek.me
License: UNKNOWN
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Description-Content-Type: text/markdown

# Quick-SQLite

## Introduction

Quick-SQLite is intended for programmers that dislike the unattractive and needlessly extensive SQLite3 API. Quick-SQLite not only reduces the ugly-looking function set with a clean and organised function set, but it also comes with many useful settings such as auto-commiting, automatic reconnecting, and event listeners. The integrated events listeners - demonstrated later on - are functions inside your script that are called every time something specific happens, for example, the disconnect listener is called every time the connection disconnects, more on that later.

## Installation

To install Quick-SQLite, just run the following command:

```pip install quick-sqlite```

## Comparison

### SQLite3

```
from sqlite3 import connect

with connect("Database.db") as c:
    data = c.cursor().execute("SELECT Z FROM Table WHERE X=?", ("Y",)).fetchone()[0]
    c.cursor().execute("UPDATE Table SET X=? WHERE X=?", ("Y", f"{data}Y"))
    c.commit()
```

### Quick-SQLite

```
from quicksqlite import Connection

c = Connection(path="Database.db", auto_connect=True)
c.update("Table", "X", f"{c.select('Table', 'Z', column_w='X', value_w='Y')[0]}Y")
```

## Examples

### Minimal Usage

```
from quicksqlite import Connection

# Define our connection instance
con = Connection(path="Database.db", auto_commit=False, reconnects=5, auto_connect=True)

# Create table
con.create_table("Employees", ["Name", "Age", "Salary"], ["TEXT", "INTEGER", "REAL"])

# Insert row
con.insert("Employees", ["Andrew Anderson", 32, 100.00])

# Update row
con.update("Employees", "Salary", 110.00, column_w="Name", value_w="Andrew Anderson")

# Select row
print(con.select("Employees", "Age", column_w="Name", value="Andrew Anderson", fetchall=False, random=False, limit=1))

# Delete row
con.delete("Employees", column_w="Name", value_w="Andrew Anderson")

# Drop table
con.drop_table("Employees")

# Commit changes
con.commit()

# Rollback
con.rollback()

# Close the connection
con.close()
```

### Using listeners

```
from quicksqlite import Connection

# Define our connection instance
con = Connection(path="Database.db", auto_commit=True, reconnects=5)

@con.listen
def on_connect(db):
    print(f"Connected to {db}")

@con.listen
def on_disconnect(db):
    print(f"Disconnected from {db}")

@con.listen
def on_reconnect(db, attempt_number):
    print(f"Reconnected from {db} on attempt number {attempt_number}")

@con.listen
def on_transaction_success(db, action):
    print(f"A transaction was completed in {db}, the action was {action}")

@con.listen
def on_rollback(db):
    print(f"The last commit to {db} has been rolled back")

@con.listen
def on_commit(db):
    print(f"Changes to {db} have been saved")

# Create table
con.create_table("Employees", ["Name", "Age", "Salary"], ["TEXT", "INTEGER", "REAL"])

# Insert row
con.insert("Employees", ["Andrew Anderson", 32, 100.00])

# Update row
con.update("Employees", "Salary", 110.00, column_w="Name", value_w="Andrew Anderson")

# Select row
print(con.select("Employees", "Age", column_w="Name", value="Andrew Anderson", fetchall=False, random=False, limit=1))

# Delete row
con.delete("Employees", column_w="Name", value_w="Andrew Anderson")

# Drop table
con.drop_table("Employees")

# Rollback
con.rollback()

# Close the connection
con.close()
```

### In-class Example

```
from quicksqlite import Connection

class MyClass(Connection):
    def __init__(self):
        # Define our connection instance
        super().__init__(path="Database.db", auto_commit=True, reconnects=5)

        # Setup listeners
        self.listen(self.some_function, name="connect")
        self.listen(self.on_disconnect)
        self.listen(self.on_reconnect)
        self.listen(self.on_success)
        self.listen(self.on_rollback)
        self.listen(self.on_commit)

    def some_function(self, db):
        print(f"Connected to {db}")

    def name_can_be_just_connect(self, db):
        print(f"Disconnected from {db}")

    def on_reconnect(self, db, attempt_number):
        print(f"Reconnected from {db} on attempt number {attempt_number}")

    def on_success(self, db, action):
        print(f"A transaction was completed in {db}, the action was {action}")

    def on_rollback(self, db):
        print(f"The last commit to {db} has been rolled back")

    def on_commit(self, db):
        print(f"Changes to {db} have been saved")

if __name__ == "__main__":
    con = MyClass()

# Functions from the previous examples are used exactly the same as they are here, for example:
con.create_table("Employees", ["Name", "Age", "Salary"], ["TEXT", "INTEGER", "REAL"])

con.close()
```

